var cuckoograph = (function() {
	/*
	the data is asumed to be in a variable "graph_raw_data" put in the html by djano
	requires highcharts and jqery
	*/
	var graph_overview_height = 85; // px
	var graph_details_height = 300; // px
	var graph_width = 0 //px (set by click)
	var graph_data = graph_raw_data;
	var graph_overview_div = 'graph_process_overview';
	var graph_details_div = 'graph_process_details';
	var link_controls_event = '#graph_controls_event';
	var link_controls_grouping = '#graph_controls_grouping'
	var parent_container = ".tab-content"

	// own internal variables
	var hcg1; // highchart overview graph
	var hcg2; // highchart details graph
	var activeGraphs = {};
	var apiCallsMax = {};
	var controls = {
		processEvent: 'event', // time or event
		processGroupby: 'category', // api or category
	};
	var apiCalls = {
		api: {},
		category: {}
	};
	var chartDefaultOptions = {
		chart: {
			backgroundColor: false,
			animation: false,
			zoomType: 'x',
		},
		credits: { enabled: false, },
		legend: { enabled: true, layout: 'horizontal', borderWidth: 0, verticalAlign: 'bottom', floating: false, },
		title: { text: '', },
		subtitle: {	text: '' },
		tooltip: { enabled: true,
			formatter: function() {
				return this.point.tooltip;
			}
		},
		xAxis: {},
		yAxis: {},
	}

	// hook html links
	function activateLinks() {
		console.log("activating links");
		$(link_controls_event).click( function() {
			controls.processEvent = (controls.processEvent === 'event') ? 'time' : 'event';
			$(link_controls_event).text(controls.processEvent);
			reDrawGraph(hcg2);
		}).text(controls.processEvent);

		$(link_controls_grouping).click( function() {
			controls.processGroupby = (controls.processGroupby === 'category') ? 'api' : 'category';
			$(link_controls_grouping).text(controls.processGroupby);
			reDrawGraph(hcg2);
		}).text(controls.processGroupby);
	}

	// id=graph_hook is added to /templates/analysis/_graph.html
	function resizeGraphs( width ) {
		graph_width = width;
		hcg1.setSize(graph_width,graph_overview_height);
		hcg2.setSize(graph_width,graph_details_height);
	}

	// start running
	function activateGraphs() {
		console.log("drawing graphs");
		apiCalls = readAPICalls( apiCalls );
		//initiate overview graph
		drawGraph1( chartDefaultOptions );
		//initiate details graph
		drawGraph2( chartDefaultOptions );
	}


	function drawGraph1( chartDefaultOptions ) {
		var options = jQuery.extend(true, {}, chartDefaultOptions);
		options.chart.renderTo = graph_overview_div;
		options.legend = { enabled: false }
		options.plotOptions = { bar: { pointWidth: 5 }, column: { pointWidth: 7 } };
		options.xAxis = {
			type: 'datetime',
			dateTimeLabelFormats: {
				second: '%M:%S'
			}
		};
		//without a max value, the plotbands won't show when all series are disabled at first run
		options.yAxis = { labels: { enabled: false }, gridLineWidth: 0, title: { text: '' }, min: 0, max: 1, tickInterval : 1 };
		options.plotOptions.series = {};
		options.plotOptions.series.point = {};
		options.plotOptions.series.point.events = {
			click: function() {
				var thisProcess = this.options.id;
				var relatedSeries = hcg2.series[thisProcess];
				if (relatedSeries.visible) {
					relatedSeries.hide();
					activeGraphs[thisProcess] = false;
				}
				else {
					relatedSeries.show();
					activeGraphs[thisProcess] = true;
				}
			}
		};

		options.series = calcGraph1();
		hcg1 = new Highcharts.Chart( options );
	}


	function drawGraph2( chartDefaultOptions ) {
		var options = jQuery.extend(true, {}, chartDefaultOptions);
		options.chart.renderTo = graph_details_div;
		options.chart.resetZoomButton = {
			relativeTo: 'chart',
			position: {
				x: -120,
				y: 40
			}
		}
		options.title = 'API calls';
		var xAxisType = (controls.processEvent === 'event') ? ' linear' : 'datetime';
		options.xAxis = { type: xAxisType };
		var yAxisMax = apiCallsMax[controls.processGroupby];
		options.yAxis = { minRange: 50, categories: generateYaxisCategories(), opposite: false, labels: { enabled: true, style: {fontSize: '7pt'} }, gridLineWidth: 0, title: { text: '' }, min: 0, max: yAxisMax, tickInterval : 1 };
		options.plotOptions = {series: {} };
		//series wont be drawn if more than default 1000 point and data type is an object
		//workaround is to use arrays or set it higher like this:
		options.plotOptions.series.turboThreshold = 3000;
		options.plotOptions.series.events = {
			legendItemClick: function() {
				activeGraphs[this.options.id] = !this.visible;
			}
		};
		options.yAxis.plotBands = generatePlotbands();
		options.series = calcGraph2();
		hcg2 = new Highcharts.Chart( options );

		function generateYaxisCategories(){
			var categories = [''];
			var source = apiCalls[controls.processGroupby];

			for (var i in source) {
				categories.push(i);
			}
			categories.push('');
			return categories;
		}

		function generatePlotbands(){
			var plotBands = [];
			var plotBandColors = ['#F5F5F5', '#FFFFFF']
			var source = apiCalls[controls.processGroupby];
			for (var i in source) {
				var thisPlotBandColor = ( source[i] % 2 === 0) ? plotBandColors[1] : plotBandColors[0];
				plotBands.push( { from: source[i] - 0.5, to: source[i] + 0.5, color: thisPlotBandColor } )
			}
			return plotBands;
		}
	}


	function readAPICalls( apiCalls ){
		for (var i in graph_data) {
			var process = graph_data[i];
			for (var j in process.calls) {
				var thisCall = process.calls[j];
				apiCalls.api[thisCall.api] = true;
				apiCalls.category[thisCall.category] = true;
			}
		}
		//sort objects by name?

		//asign incremental numbers
		var countAPI = 1; var apiNr = {};
		var countCat = 1; var catNr = {};
		for (var i in apiCalls.api) { apiNr[i] = countAPI; countAPI++; }
		for (var i in apiCalls.category) { catNr[i] = countCat; countCat++; }
		apiCalls.api = apiNr; apiCalls.category = catNr;

		//used to update y-axis max value
		apiCallsMax.api = countAPI; apiCallsMax.category = countCat;
		return apiCalls;
	}


	function apiToInt( string, lookupTable ) {
		if ( lookupTable[string] !== undefined ) {
			return lookupTable[string];
		}
		else {
			console.log( string );
			return 0;
		}
	}


	function datformatToUTC( date ) {
		// format "2012-09-08 08:30:47,067"
		var date = new Date(
			date.slice(0, 4), //year
			date.slice(5, 7) - 1, //month
			date.slice(8, 10), //day
			date.slice(11, 13), //hour
			date.slice(14, 16), //minutes
			date.slice(17, 19), //second
			date.slice(20, 23) //ms
		);
		return date.getTime();
	}


	function calcGraph1() {
		var data = [];
		var processes = graph_data;
		var numOfProcesses = 0;
		var pointID = 0;
		for ( var i in processes ) {
			numOfProcesses++;
			var tooltipText =
				processes[ i ].process_name +
				'<br>PID: ' + processes[ i ].process_id +
				' (Parent: ' + processes[ i ].parent_id + ')';
			data.push({ x: datformatToUTC( processes[ i ].first_seen ), y:1, tooltip:tooltipText, process:processes[ i ].process_name, id: pointID });
			pointID++;
		}
		var series = [
			{
				name: 'Processes (' + numOfProcesses + ')',
				type: 'column',
				data: data,
			}
		];
		return series;
	}


	function reDrawGraph(chart) {
		console.log("updating graph")
		chart.destroy();
		drawGraph2( chartDefaultOptions );
		hcg2.setSize($(parent_container).width(), graph_details_height);
	}


	function calcGraph2() {
		var series = [];
		var processes = graph_data;
		var seriesID = 0;
		for ( var i in processes ) {
			var count = 1;
			var data = [];
			var calls = processes[i].calls;
			for ( var j in calls ) {
				var tooltipText = '<b>' + calls[j].api + '</b>';
				switch (controls.processGroupby) {
					case 'api':
						yValue = apiToInt(calls[j].api, apiCalls.api);
						break;
					case 'category':
						yValue = apiToInt(calls[j].category, apiCalls.category);
						break;
				}
				switch (controls.processEvent) {
					case 'time':
						data.push( { x:datformatToUTC(calls[j].timestamp), y:yValue, tooltip:tooltipText } );
						break;
					case 'event':
						data.push( { x:count, y:yValue, tooltip:tooltipText } );
						break;
				}
				count++;
			}
			var seriesVisible = (activeGraphs[seriesID]) ? activeGraphs[seriesID] : false;
			series.push(
				{
					name: processes[ i ].process_name,
					id: seriesID,
					type: 'line',
					data: data,
					visible: seriesVisible
				}
			);
			seriesID++;
		}
		return series;
	}


	return {
		links: activateLinks,
		start: activateGraphs,
		resize: resizeGraphs,
	}
})();

cuckoograph.links();
cuckoograph.start();
// hack to make graphs fill 100%
$( "#graph_hook" ).click( function() {
	console.log("Resizing graphs");
	cuckoograph.resize( $(".tab-content").width() );
});

